# [hackerrank](https://www.hackerrank.com)

## Algorithm

### implementation
* [Apple and Orange](https://www.hackerrank.com/challenges/apple-and-orange)
```
algorithms/implementation/apple_orange.js
```

* [Between two Sets](https://www.hackerrank.com/challenges/between-two-sets)
* A, B 두개의 집합의 원소들에 대해 아래의 조건을 만족하는 x 값이 몇개인지를 출력
* A 집합의 원소는 a1, a2, ... aN (이하 an), B 집합의 원소는 b1, b2, ... bM (이하 bn)
* x % an = 0, bn % x = 0을 만족하는 x의 값은 몇개인지를 출력
```
algorithms/implementation/between_two_sets.js
```

* [Bigger is Greater](https://www.hackerrank.com/challenges/bigger-is-greater)
* 주어진 단어의 알파벳 순서로 다음번째 큰 단어 조합 출력 [(알고리즘 참고)](https://www.nayuki.io/page/next-lexicographical-permutation-algorithm)
```
algorithms/implementation/bigger_is_greater.js
```

### Sorting
* [Insertion Sort - part1](https://www.hackerrank.com/challenges/insertionsort1)
```
algorithms/sorting/insertion1.js
```

* [Insertion Sort - part2](https://www.hackerrank.com/challenges/insertionsort2)
```
algorithms/sorting/insertion2.js
```

* [Quick Sort - part1](https://www.hackerrank.com/challenges/quicksort1)
```
algorithms/sorting/quick1.js
```

* [Quick Sort - part2](https://www.hackerrank.com/challenges/quicksort2)
```
algorithms/sorting/quick2.js
```

### Strings
* [Richie Rich](https://www.hackerrank.com/challenges/richie-rich)
* 최소한의 수정으로 앞뒤가 동일한 숫자 조합만들기(수정횟수가 동일하면 가장큰수)
```
algorithms/strings/richie-rich.js
```

* [Sherlock and Anagram](https://www.hackerrank.com/challenges/sherlock-and-anagrams)
```
algorithms/strings/sherlock_and_anagrams.js
```

## Data Structure

### Arrays
* [Algorithmic Crush](https://www.hackerrank.com/challenges/crush) (Hard)
* 1차 배열의 특정 인덱스에 k값을 덧셈한다고 할때, 배열에 있는 최대값을 구하기
* 복잡도를 O(N)의 형태로 풀어야 하는 것이 관건

```
data_structre/arrays/algorithmic_crush.rb
```
