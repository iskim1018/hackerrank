# [hackerrank](https://www.hackerrank.com)

## Algorithm

### implementation
* [Bigger is Greater](https://www.hackerrank.com/challenges/bigger-is-greater)
* 주어진 단어보다 알파벳 정렬기준으로 다음번째 단어 출력 [(알고리즘 참고)](https://www.nayuki.io/page/next-lexicographical-permutation-algorithm)
* ex) abdc -> acbd
```
algorithms/implementation/bigger_is_greater.js
```

### Strings
* [Richie Rich](https://www.hackerrank.com/challenges/richie-rich)
* 변경 가능한 횟수가 지정되었을때 해당 횟수만큼 숫자를 변경하여 앞뒤가 똑같은('토마토', '리효리') 구조로 변경. 가능한 결과가 다양할 경우에는 최대값을 출력
* ex) [1, 3943 -> 3993], [3, 092282 -> 992299]
```
algorithms/strings/richie-rich.js
```

## Data Structure

### Arrays
* [Algorithmic Crush](https://www.hackerrank.com/challenges/crush)
* 1차 배열의 특정 인덱스에 k값을 덧셈한다고 할때, 배열에 있는 최대값을 구하기
* 복잡도를 O(N)의 형태로 풀어야 하는 것이 관건

```
data_structre/arrays/algorithmic_crush.rb
```
